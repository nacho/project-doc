% mainfile:main.tex

\chapter{Invalid characters}

\section{Analysis and Design}

In the version gedit 2.30 we introduced a new way for opening and saving files by using input and output streams. An input stream allows us to read an stream from a specific source and attach to it GFilterInputStreams to make operations on it while we are reading the specific stream. An output stream allows us to write data in one source and attach GFilterOutputStreams to make operations in the written data. In the figures \ref{fig:InputStreams} and \ref{fig:OutputStreams}, we can check the diagrams of how gedit deals with this two situations.

\addfigure[scale=0.5]{./images/input-streams}{gedit input streams flow diagram}{fig:InputStreams}

\addfigure[scale=0.5]{./images/output-streams}{gedit output streams flow diagram}{fig:OutputStreams}

\section{Implementation}

\subsection{Bug}

\noindent\url{https://bugzilla.gnome.org/show_bug.cgi?id=502947}

\section{Tests}

To test this implementation, it was used a set of unit tests. This is a very low level implementation and one of the most important part of gedit, as we have to ensure that the data will not get lost and will be valid.

\begin{lstlisting}[style=GObject]
static void
test_consecutive_write (const gchar *inbuf,
			const gchar *outbuf,
			gsize write_chunk_len,
			GeditDocumentNewlineType newline_type)
{
	GeditDocument *doc;
	GOutputStream *out;
	gsize len;
	gssize n, w;
	GError *err = NULL;
	gchar *b;
	GeditDocumentNewlineType type;
	GSList *encodings = NULL;

	doc = gedit_document_new ();
	encodings = g_slist_prepend (encodings, (gpointer)gedit_encoding_get_utf8 ());
	out = gedit_document_output_stream_new (doc, encodings);

	n = 0;

	do
	{
		len = MIN (write_chunk_len, strlen (inbuf + n));
		w = g_output_stream_write (out, inbuf + n, len, NULL, &err);
		g_assert_cmpint (w, >=, 0);
		g_assert_no_error (err);

		n += w;
	} while (w != 0);

	g_output_stream_flush (out, NULL, &err);

	g_assert_no_error (err);

	type = gedit_document_output_stream_detect_newline_type (GEDIT_DOCUMENT_OUTPUT_STREAM (out));
	g_assert (type == newline_type);

	g_output_stream_close (out, NULL, &err);
	g_assert_no_error (err);

	g_object_get (G_OBJECT (doc), "text", &b, NULL);

	g_assert_cmpstr (outbuf, ==, b);
	g_free (b);

	g_assert (gtk_text_buffer_get_modified (GTK_TEXT_BUFFER (doc)) == FALSE);

	g_object_unref (doc);
	g_object_unref (out);
}

static void
test_invalid_utf8 ()
{
	test_consecutive_write ("foobar\n\xef\xbf\xbe", "foobar\n\\EF\\BF\\BE", 10,
	                        GEDIT_DOCUMENT_NEWLINE_TYPE_LF);
	test_consecutive_write ("foobar\n\xef\xbf\xbezzzzzz\n", "foobar\n\\EF\\BF\\BEzzzzzz", 10,
	                        GEDIT_DOCUMENT_NEWLINE_TYPE_LF);
	test_consecutive_write ("\xef\xbf\xbezzzzzz\n", "\\EF\\BF\\BEzzzzzz", 10,
	                        GEDIT_DOCUMENT_NEWLINE_TYPE_LF);
}
\end{lstlisting}

In this tests, we check that introducing some text with invalid characters at the end, middle and beginning of a string, we get them escaped getting the expected result and without getting any error in the operation.
