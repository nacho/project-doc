% mainfile:main.tex

\chapter{libpeas}

There was the decision from a lot of time ago to try to convert the plugin system used in gedit into an standalone library. The main reason for this, was that several applications were copying the gedit plugin system and then making small modifications on it to adapt it as they preferred. The main problem to not do it before was that we needed to break the API and ABI stability, which is not a good thing is you want to keep you user base stable. As explained in the chapter \ref{chap:GFile}, with the process to \GNOME 3.0, an opportunity to break it was provided.

With the help of the rest of the \emph{gedit team}, Steve Fr\'ecinaux was the one that took care of creating this library. Even if I am not the one that created it, I was helping a lot to port gedit and other applications and with the design, pointing out problems and providing some patches. In this chapter it is provided an overview of the whole port, the changes in the design and how it changed the implementation of plugins, pointing out examples and the advantages of the new design.

See that one of the design decisions when libpeas was implemented was to make it gobject-introspection based (see \ref{sec:GObjectIntrospection}). This was one of the main problems, the port to use this library was not straightforward.

\section{Analysis}

\addfigure{./images/libpeas1}{Old Plugin system diagram}{fig:OldPluginSystemDiagram}

In the figure \ref{fig:OldPluginSystemDiagram}, it can be checked the class diagram of the plugin system used before any work was done in the libpeas library. In order to understand better the next parts of this chapter, an overview of the main classes in this diagram is needed.

\subsection{GeditPluginsEngine}

This is the main class of the plugin engine. It takes care of loading and unloading a specific plugin, activate and deactivate the plugins for a specific window and to get the information for a specific plugin.

The GeditWindow has a direct link to this class by saying to it when it has to activate or deactivate a plugin. Also, it listens to the signals activate\_plugin and deactivate\_plugin (which should be called load\_plugin and unload\_plugin) to actually activate them.

This class is a singleton so it can be accessed at any point by any class.

\newpage
\subsection{GeditPluginManager}

\addfigure[scale=0.5]{./images/gedit-plugins-dialog}{Gedit plugins dialog}{fig:GeditPluginsDialog}

As shown in the figure \ref{fig:GeditPluginsDialog} is the user interface exposed in the gedit preferences dialog to be able to load or unload plugins. This widget calls to load or unload methods from GeditPluginsEngine. This later will emit the related signal listened by the window as spotted before.

\addfigure[scale=0.5]{./images/libpeas2}{First design using libpeas}{fig:FirstDesignUsingLibpeas}

\addfigure{./images/libpeas3}{Design using extensions}{fig:DesignExtensions}

\section{Old Plugin implementation}

Here it is shown an snippet of how the previous plugin looked:

\subsection{Minimalist plugin}

\begin{lstlisting}[style=python]

import gedit

class ExamplePyPlugin(gedit.Plugin):
    def activate(self, window):
        pass

    def deactivate(self, window):
        pass

    def update_ui(self, window):
        pass

\end{lstlisting}

As we can see in this example each plugin must implement three methods:
\begin{enumerate}
  \item \textbf{activate:} called when the plugin is activated. This is usually used for the initialization of the plugin itself.
  \item \textbf{deactivate:} called when the plugin is deactivated. Used to dispose the plugin.
  \item \textbf{update\_ui:} called when a change in user interface of the window has been introduced. i.e when a tab in the window has been switched.
\end{enumerate}

\subsection{Window controller}\label{sec:WindowController}

As it was explained in the chapter \ref{chap:InitialAnalysis}, gedit is a \emph{single instance application}. This means that for each instance of the application we can have several windows. This is applied also to the plugins. One plugin instance will be created only once, and then the activate/deactivate/update\_ui methods will be called for each window.

This fact has made us to introduce the \emph{window controller}, which is one class that takes care to control a specific window. The plugin instance will have a hash table that takes care of calling the right window controller instance method. This allows a simple way to implement plugins.

The main problem of this, was that each plugin developer needed to know internal details of gedit in order to create a plugin correctly. In the example below, it can be shown how it was dealed with this before.

\begin{lstlisting}[style=python]

import gedit

class ExamplePyWindowHelper:
    def __init__(self, plugin, window):
        print "Plugin created for", window
        self._window = window
        self._plugin = plugin

    def deactivate(self):
        print "Plugin stopped for", self._window
        self._window = None
        self._plugin = None

    def update_ui(self):
        # Called whenever the window has been updated (active tab
        # changed, etc.)
        print "Plugin update for", self._window

class ExamplePyPlugin(gedit.Plugin):
    def __init__(self):
        gedit.Plugin.__init__(self)
        self._instances = {}

    def activate(self, window):
        self._instances[window] = ExamplePyWindowHelper(self, window)

    def deactivate(self, window):
        self._instances[window].deactivate()
        del self._instances[window]

    def update_ui(self, window):
        self._instances[window].update_ui()

\end{lstlisting}

\section{New plugin implementation}

A plugin will be able to have one or more extensions. Each extension is derived from GObject.Object and must implement one of the interfaces that gedit provides for the extension points.

\begin{lstlisting}[style=python]

from gi.repository import GObject, Gedit

class ExamplePyWindowActivatable:
    __gtype_name__ = "ExamplePyWindowActivatable"

    window = GObject.property(type=Gedit.Window)

    def __init__(self):
        GObject.Object.__init__(self)

    def do_activate(self):
        print "Plugin created for", self.window

    def do_deactivate(self):
        print "Plugin stopped for", self.window

    def do_update_state(self):
        # Called whenever the window has been updated (active tab
        # changed, etc.)
        print "Plugin update for", self.window

\end{lstlisting}

This example makes the same as the one provided in the section \ref{sec:WindowController}. As we can see it is a lot easier to implement and it needs a smaller learning curve. For each window a new extension point is created so the class ExamplePyWindowActivatable will be instantiated for each of them.

